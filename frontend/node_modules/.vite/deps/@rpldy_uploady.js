import {
  BATCH_STATES,
  DEFAULT_OPTIONS,
  FILE_STATES,
  MissingUrlError,
  NoDomUploady_default,
  UPLOADER_EVENTS,
  UploadyContext_default,
  XHR_SENDER_TYPE,
  assertContext_default,
  composeEnhancers_default,
  createContextApi,
  generateUploaderEventHook,
  generateUploaderEventHookWithState,
  getIsUploadOptionsComponent,
  getVersion,
  hasWindow_default,
  import_invariant,
  logWarning,
  logger_exports,
  markAsUploadOptionsComponent,
  send,
  uploader_default,
  useAbortAll_default,
  useAbortBatch_default,
  useAbortItem_default,
  useAllAbortListener,
  useBatchAbortListener,
  useBatchAddListener,
  useBatchCancelledListener,
  useBatchErrorListener,
  useBatchFinalizeListener,
  useBatchFinishListener,
  useBatchProgressListener,
  useBatchStartListener,
  useItemAbortListener,
  useItemCancelListener,
  useItemErrorListener,
  useItemFinalizeListener,
  useItemFinishListener,
  useItemProgressListener,
  useItemStartListener,
  useRequestPreSend,
  useUploadOptions_default,
  useUploadyContext_default,
  withBatchStartUpdate_default,
  withRequestPreSendUpdate_default,
  xhrSender_default
} from "./chunk-5AZGWN2G.js";
import {
  require_react_dom
} from "./chunk-D7552MD7.js";
import {
  require_react
} from "./chunk-BQYK6RGN.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@rpldy/uploady/lib/esm/Uploady.js
var import_react = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}
var NO_CONTAINER_ERROR_MSG = "Uploady - Container for file input must be a valid dom element";
var renderInput = (inputProps, instanceOptions, ref) => import_react.default.createElement("input", _extends({}, inputProps, {
  name: instanceOptions.inputFieldName,
  type: "file",
  ref
}));
var renderInPortal = (container, isValidContainer, inputProps, instanceOptions, ref) => container && isValidContainer ? import_react_dom.default.createPortal(renderInput(inputProps, instanceOptions, ref), container) : null;
var FileInputField = (0, import_react.memo)((0, import_react.forwardRef)(({
  container,
  noPortal,
  ...inputProps
}, ref) => {
  const instanceOptions = useUploadOptions_default();
  const isValidContainer = container && container.nodeType === 1;
  (0, import_invariant.default)(isValidContainer || !hasWindow_default(), NO_CONTAINER_ERROR_MSG);
  return noPortal ? renderInput(inputProps, instanceOptions, ref) : renderInPortal(container, isValidContainer, inputProps, instanceOptions, ref);
}));
var Uploady = (props) => {
  const {
    multiple = true,
    capture,
    accept,
    webkitdirectory,
    children,
    inputFieldContainer,
    customInput,
    fileInputId,
    noPortal = false,
    ...noDomProps
  } = props;
  const container = !customInput ? inputFieldContainer || (hasWindow_default() ? document.body : null) : null;
  const internalInputFieldRef = (0, import_react.useRef)();
  return import_react.default.createElement(NoDomUploady_default, _extends({}, noDomProps, {
    inputRef: internalInputFieldRef
  }), !customInput ? import_react.default.createElement(FileInputField, {
    container,
    multiple,
    capture,
    accept,
    webkitdirectory: webkitdirectory?.toString(),
    style: {
      display: "none"
    },
    ref: internalInputFieldRef,
    id: fileInputId,
    noPortal
  }) : null, children);
};
var Uploady_default = Uploady;

// node_modules/@rpldy/uploady/lib/esm/useFileInput.js
var import_react2 = __toESM(require_react());
var getUrl = (form) => {
  const loc = window.location;
  let url = form.getAttribute("action") || "";
  url = url.replace(/\s/g, "");
  let path;
  switch (true) {
    case url === "":
      url = loc.href;
      break;
    case url.startsWith("/"):
      url = `${loc.protocol}//${loc.host}${url}`;
      break;
    case !/:\/\//.test(url):
      path = loc.pathname.split("/").slice(0, -1).concat("").join("/");
      url = `${loc.protocol}//${loc.host}${path}${url}`;
      break;
  }
  return url;
};
var getNewDestination = (input, form) => {
  const method = form?.getAttribute("method"), url = form && getUrl(form);
  return {
    filesParamName: input.getAttribute("name"),
    method: method ? method.toUpperCase() : void 0,
    url
  };
};
var retrieveDestinationFromInput = (input, onUpdate) => {
  let destination, stopObserving;
  const form = input.closest("form");
  if (form) {
    destination = getNewDestination(input, form);
    logger_exports.debugLog(`Uploady.useFileInput: using custom input's parent form url ${destination.url || ""} and method ${destination.method || ""}`);
    let observer = new MutationObserver((records) => {
      if (records[0]?.attributeName === "action") {
        const newDestination = getNewDestination(input, form);
        if (newDestination.url) {
          logger_exports.debugLog(`Uploady.useFileInput: form action attribute changed to ${newDestination.url}`);
          onUpdate(newDestination);
        }
      }
    });
    observer?.observe(form, {
      attributes: true,
      attributeFilter: ["action"]
    });
    stopObserving = () => {
      observer?.disconnect();
      observer = null;
    };
  }
  onUpdate(destination || getNewDestination(input));
  return {
    stopObserving
  };
};
var useFileInput = (fileInputRef) => {
  const context = useUploadyContext_default();
  if (fileInputRef) {
    context.setExternalFileInput(fileInputRef);
  }
  (0, import_react2.useEffect)(() => {
    let stopObservingCallback;
    if (fileInputRef?.current && "closest" in fileInputRef.current) {
      const input = fileInputRef.current;
      const uploaderOptions = context.getOptions();
      if (!uploaderOptions.destination || !uploaderOptions.destination.url) {
        const {
          stopObserving
        } = retrieveDestinationFromInput(input, (newDestination) => {
          context.setOptions({
            destination: newDestination
          });
        });
        stopObservingCallback = stopObserving;
      }
    }
    return () => {
      stopObservingCallback?.();
    };
  }, [fileInputRef, context]);
  return !!fileInputRef ? fileInputRef : context.getInternalFileInput();
};
var useFileInput_default = useFileInput;

// node_modules/@rpldy/uploady/lib/esm/index.js
var esm_default = Uploady_default;
export {
  BATCH_STATES,
  DEFAULT_OPTIONS,
  FILE_STATES,
  MissingUrlError,
  NoDomUploady_default as NoDomUploady,
  UPLOADER_EVENTS,
  Uploady_default as Uploady,
  UploadyContext_default as UploadyContext,
  XHR_SENDER_TYPE,
  assertContext_default as assertContext,
  composeEnhancers_default as composeEnhancers,
  createContextApi,
  uploader_default as createUploader,
  esm_default as default,
  generateUploaderEventHook,
  generateUploaderEventHookWithState,
  getIsUploadOptionsComponent,
  getVersion as getUploadyVersion,
  xhrSender_default as getXhrSend,
  logWarning,
  markAsUploadOptionsComponent,
  send,
  useAbortAll_default as useAbortAll,
  useAbortBatch_default as useAbortBatch,
  useAbortItem_default as useAbortItem,
  useAllAbortListener,
  useBatchAbortListener,
  useBatchAddListener,
  useBatchCancelledListener,
  useBatchErrorListener,
  useBatchFinalizeListener,
  useBatchFinishListener,
  useBatchProgressListener,
  useBatchStartListener,
  useFileInput_default as useFileInput,
  useItemAbortListener,
  useItemCancelListener,
  useItemErrorListener,
  useItemFinalizeListener,
  useItemFinishListener,
  useItemProgressListener,
  useItemStartListener,
  useRequestPreSend,
  useUploadOptions_default as useUploadOptions,
  useUploadyContext_default as useUploady,
  useUploadyContext_default as useUploadyContext,
  withBatchStartUpdate_default as withBatchStartUpdate,
  withRequestPreSendUpdate_default as withRequestPreSendUpdate
};
//# sourceMappingURL=@rpldy_uploady.js.map
