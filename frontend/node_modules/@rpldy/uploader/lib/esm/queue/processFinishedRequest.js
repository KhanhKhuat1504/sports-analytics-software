import { FILE_STATES, logger } from "@rpldy/shared";
import { UPLOADER_EVENTS, ITEM_FINALIZE_STATES } from "../consts";
import { cleanUpFinishedBatches, incrementBatchFinishedCounter, getBatchDataFromItemId } from "./batchHelpers";
import { finalizeItem } from "./itemHelpers";
export const FILE_STATE_TO_EVENT_MAP = {
  [FILE_STATES.PENDING.valueOf()]: null,
  [FILE_STATES.ADDED.valueOf()]: UPLOADER_EVENTS.ITEM_START,
  [FILE_STATES.FINISHED.valueOf()]: UPLOADER_EVENTS.ITEM_FINISH,
  [FILE_STATES.ERROR.valueOf()]: UPLOADER_EVENTS.ITEM_ERROR,
  [FILE_STATES.CANCELLED.valueOf()]: UPLOADER_EVENTS.ITEM_CANCEL,
  [FILE_STATES.ABORTED.valueOf()]: UPLOADER_EVENTS.ITEM_ABORT,
  [FILE_STATES.UPLOADING.valueOf()]: UPLOADER_EVENTS.ITEM_PROGRESS
};
const getIsFinalized = item => !!~ITEM_FINALIZE_STATES.indexOf(item.state);
const processFinishedRequest = (queue, finishedData, next) => {
  finishedData.forEach(itemData => {
    const state = queue.getState();
    const {
      id,
      info
    } = itemData;
    logger.debugLog("uploader.processor.queue: request finished for item - ", {
      id,
      info
    });
    if (state.items[id]) {
      queue.updateState(state => {
        const item = state.items[id];
        item.state = info.state;
        item.uploadResponse = info.response;
        item.uploadStatus = info.status;
        if (getIsFinalized(item)) {
          delete state.aborts[id];
        }
      });
      const item = queue.getState().items[id];
      if (info.state === FILE_STATES.FINISHED && item.completed < 100) {
        const size = item.file?.size || 0;
        queue.handleItemProgress(item, 100, size, size);
      }
      const {
        itemBatchOptions
      } = getBatchDataFromItemId(queue, id);
      const batchOptions = itemBatchOptions[id];
      const itemState = item.state.valueOf();
      if (FILE_STATE_TO_EVENT_MAP[itemState]) {
        queue.trigger(FILE_STATE_TO_EVENT_MAP[itemState], item, batchOptions);
      }
      if (getIsFinalized(item)) {
        incrementBatchFinishedCounter(queue, item.batchId);
        queue.trigger(UPLOADER_EVENTS.ITEM_FINALIZE, item, batchOptions);
      }
    }
    finalizeItem(queue, id);
  });
  cleanUpFinishedBatches(queue);
  next(queue);
};
export default processFinishedRequest;